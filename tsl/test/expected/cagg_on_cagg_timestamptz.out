-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Setup test variables
\set IS_DISTRIBUTED FALSE
\set IS_TIME_DIMENSION TRUE
\set TIME_DIMENSION_DATATYPE TIMESTAMPTZ
\set CAGG_NAME_1ST_LEVEL conditions_summary_1_hourly
\set CAGG_NAME_2TH_LEVEL conditions_summary_2_daily
\set CAGG_NAME_3TH_LEVEL conditions_summary_3_weekly
\set BUCKET_WIDTH_1ST 'INTERVAL \'1 hour\''
\set BUCKET_WIDTH_2TH 'INTERVAL \'1 day\''
\set BUCKET_WIDTH_3TH 'INTERVAL \'1 week\''
SET timezone TO 'UTC';
-- Run tests
\ir include/cagg_on_cagg_common.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\if :IS_DISTRIBUTED
\echo 'Running distributed hypertable tests'
\else
\echo 'Running local hypertable tests'
Running local hypertable tests
\endif
SET ROLE :ROLE_DEFAULT_PERM_USER;
-- CAGGs on CAGGs tests
CREATE TABLE conditions (
  time :TIME_DIMENSION_DATATYPE NOT NULL,
  temperature NUMERIC
);
\if :IS_DISTRIBUTED
  \if :IS_TIME_DIMENSION
    SELECT table_name FROM create_distributed_hypertable('conditions', 'time', replication_factor => 2);
  \else
    SELECT table_name FROM create_distributed_hypertable('conditions', 'time', chunk_time_interval => 10, replication_factor => 2);
  \endif
\else
  \if :IS_TIME_DIMENSION
    SELECT table_name FROM create_hypertable('conditions', 'time');
 table_name 
------------
 conditions
(1 row)

  \else
    SELECT table_name FROM create_hypertable('conditions', 'time', chunk_time_interval => 10);
  \endif
\endif
\if :IS_TIME_DIMENSION
  INSERT INTO conditions VALUES ('2022-01-01 00:00:00-00', 10);
  INSERT INTO conditions VALUES ('2022-01-01 01:00:00-00',  5);
  INSERT INTO conditions VALUES ('2022-01-02 01:00:00-00', 20);
\else
  CREATE OR REPLACE FUNCTION integer_now()
  RETURNS :TIME_DIMENSION_DATATYPE LANGUAGE SQL STABLE AS
  $$
    SELECT coalesce(max(time), 0)
    FROM conditions
  $$;
  \if :IS_DISTRIBUTED
    SELECT
      'CREATE OR REPLACE FUNCTION integer_now() RETURNS '||:'TIME_DIMENSION_DATATYPE'||' LANGUAGE SQL STABLE AS $$ SELECT coalesce(max(time), 0) FROM conditions $$;' AS "STMT"
      \gset
    CALL distributed_exec (:'STMT');
  \endif
  SELECT set_integer_now_func('conditions', 'integer_now');
  INSERT INTO conditions VALUES (1, 10);
  INSERT INTO conditions VALUES (2,  5);
  INSERT INTO conditions VALUES (5, 20);
\endif
-- CAGG on hypertable (1st level)
CREATE MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL
WITH (timescaledb.continuous, timescaledb.materialized_only=true) AS
SELECT
  time_bucket(:BUCKET_WIDTH_1ST, "time") AS bucket,
  SUM(temperature) AS temperature
FROM conditions
GROUP BY 1
WITH NO DATA;
-- CAGG on CAGG (2th level)
CREATE MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL
WITH (timescaledb.continuous, timescaledb.materialized_only=true) AS
SELECT
  time_bucket(:BUCKET_WIDTH_2TH, "bucket") AS bucket,
  SUM(temperature) AS temperature
FROM :CAGG_NAME_1ST_LEVEL
GROUP BY 1
WITH NO DATA;
-- CAGG on CAGG (3th level)
CREATE MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL
WITH (timescaledb.continuous, timescaledb.materialized_only=true) AS
SELECT
  time_bucket(:BUCKET_WIDTH_3TH, "bucket") AS bucket,
  SUM(temperature) AS temperature
FROM :CAGG_NAME_2TH_LEVEL
GROUP BY 1
WITH NO DATA;
-- No data because the CAGGs are just for materialized data
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

-- Turn CAGGs into Realtime
ALTER MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL SET (timescaledb.materialized_only=false);
ALTER MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL SET (timescaledb.materialized_only=false);
ALTER MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL SET (timescaledb.materialized_only=false);
-- Realtime data
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           5
 Sun Jan 02 01:00:00 2022 UTC |          20
(3 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          15
 Sun Jan 02 00:00:00 2022 UTC |          20
(2 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          35
(1 row)

-- Turn CAGGs into materialized only again
ALTER MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL SET (timescaledb.materialized_only=true);
ALTER MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL SET (timescaledb.materialized_only=true);
ALTER MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL SET (timescaledb.materialized_only=true);
-- Refresh all data
CALL refresh_continuous_aggregate(:'CAGG_NAME_1ST_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_3TH_LEVEL', NULL, NULL);
-- Materialized data
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           5
 Sun Jan 02 01:00:00 2022 UTC |          20
(3 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          15
 Sun Jan 02 00:00:00 2022 UTC |          20
(2 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          35
(1 row)

\if :IS_TIME_DIMENSION
-- Invalidate an old region
INSERT INTO conditions VALUES ('2022-01-01 01:00:00-00'::timestamptz, 2);
-- New region
INSERT INTO conditions VALUES ('2022-01-03 01:00:00-00'::timestamptz, 2);
\else
-- Invalidate an old region
INSERT INTO conditions VALUES (2,  2);
-- New region
INSERT INTO conditions VALUES (10, 2);
\endif
-- No changes
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           5
 Sun Jan 02 01:00:00 2022 UTC |          20
(3 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          15
 Sun Jan 02 00:00:00 2022 UTC |          20
(2 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          35
(1 row)

-- Turn CAGGs into Realtime
ALTER MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL SET (timescaledb.materialized_only=false);
ALTER MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL SET (timescaledb.materialized_only=false);
ALTER MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL SET (timescaledb.materialized_only=false);
-- Realtime changes, just new region
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           5
 Sun Jan 02 01:00:00 2022 UTC |          20
 Mon Jan 03 01:00:00 2022 UTC |           2
(4 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          15
 Sun Jan 02 00:00:00 2022 UTC |          20
 Mon Jan 03 00:00:00 2022 UTC |           2
(3 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          35
 Mon Jan 03 00:00:00 2022 UTC |           2
(2 rows)

-- Turn CAGGs into materialized only again
ALTER MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL SET (timescaledb.materialized_only=true);
ALTER MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL SET (timescaledb.materialized_only=true);
ALTER MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL SET (timescaledb.materialized_only=true);
-- Refresh all data
CALL refresh_continuous_aggregate(:'CAGG_NAME_1ST_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_3TH_LEVEL', NULL, NULL);
-- All changes are materialized
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           7
 Sun Jan 02 01:00:00 2022 UTC |          20
 Mon Jan 03 01:00:00 2022 UTC |           2
(4 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          17
 Sun Jan 02 00:00:00 2022 UTC |          20
 Mon Jan 03 00:00:00 2022 UTC |           2
(3 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          37
 Mon Jan 03 00:00:00 2022 UTC |           2
(2 rows)

-- TRUNCATE tests
TRUNCATE :CAGG_NAME_2TH_LEVEL;
-- This full refresh will remove all the data from the 3TH level cagg
CALL refresh_continuous_aggregate(:'CAGG_NAME_3TH_LEVEL', NULL, NULL);
-- Should return no rows
SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

-- If we have all the data in the bottom levels caggs we can rebuild
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_3TH_LEVEL', NULL, NULL);
-- Now we have all the data
SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          17
 Sun Jan 02 00:00:00 2022 UTC |          20
 Mon Jan 03 00:00:00 2022 UTC |           2
(3 rows)

SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Mon Dec 27 00:00:00 2021 UTC |          37
 Mon Jan 03 00:00:00 2022 UTC |           2
(2 rows)

-- DROP tests
\set ON_ERROR_STOP 0
-- should error because it depends of other CAGGs
DROP MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL;
psql:include/cagg_on_cagg_common.sql:178: ERROR:  cannot drop view conditions_summary_1_hourly because other objects depend on it
DROP MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL;
psql:include/cagg_on_cagg_common.sql:179: ERROR:  cannot drop view conditions_summary_2_daily because other objects depend on it
CALL refresh_continuous_aggregate(:'CAGG_NAME_1ST_LEVEL', NULL, NULL);
psql:include/cagg_on_cagg_common.sql:180: NOTICE:  continuous aggregate "conditions_summary_1_hourly" is already up-to-date
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
psql:include/cagg_on_cagg_common.sql:181: NOTICE:  continuous aggregate "conditions_summary_2_daily" is already up-to-date
\set ON_ERROR_STOP 1
-- DROP the 3TH level CAGG don't affect others
DROP MATERIALIZED VIEW :CAGG_NAME_3TH_LEVEL;
psql:include/cagg_on_cagg_common.sql:185: NOTICE:  drop cascades to table _timescaledb_internal._hyper_4_4_chunk
\set ON_ERROR_STOP 0
-- should error because it was dropped
SELECT * FROM :CAGG_NAME_3TH_LEVEL ORDER BY bucket;
psql:include/cagg_on_cagg_common.sql:188: ERROR:  relation "conditions_summary_3_weekly" does not exist at character 15
\set ON_ERROR_STOP 1
-- should work because dropping the top level CAGG
-- don't affect the down level CAGGs
TRUNCATE :CAGG_NAME_2TH_LEVEL,:CAGG_NAME_1ST_LEVEL;
CALL refresh_continuous_aggregate(:'CAGG_NAME_2TH_LEVEL', NULL, NULL);
CALL refresh_continuous_aggregate(:'CAGG_NAME_1ST_LEVEL', NULL, NULL);
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           7
 Sun Jan 02 01:00:00 2022 UTC |          20
 Mon Jan 03 01:00:00 2022 UTC |           2
(4 rows)

SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
 bucket | temperature 
--------+-------------
(0 rows)

-- DROP the 2TH level CAGG don't affect others
DROP MATERIALIZED VIEW :CAGG_NAME_2TH_LEVEL;
psql:include/cagg_on_cagg_common.sql:199: NOTICE:  drop cascades to table _timescaledb_internal._hyper_3_3_chunk
\set ON_ERROR_STOP 0
-- should error because it was dropped
SELECT * FROM :CAGG_NAME_2TH_LEVEL ORDER BY bucket;
psql:include/cagg_on_cagg_common.sql:202: ERROR:  relation "conditions_summary_2_daily" does not exist at character 15
\set ON_ERROR_STOP 1
-- should work because dropping the top level CAGG
-- don't affect the down level CAGGs
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
            bucket            | temperature 
------------------------------+-------------
 Sat Jan 01 00:00:00 2022 UTC |          10
 Sat Jan 01 01:00:00 2022 UTC |           7
 Sun Jan 02 01:00:00 2022 UTC |          20
 Mon Jan 03 01:00:00 2022 UTC |           2
(4 rows)

-- DROP the first CAGG should work
DROP MATERIALIZED VIEW :CAGG_NAME_1ST_LEVEL;
psql:include/cagg_on_cagg_common.sql:209: NOTICE:  drop cascades to table _timescaledb_internal._hyper_2_2_chunk
\set ON_ERROR_STOP 0
-- should error because it was dropped
SELECT * FROM :CAGG_NAME_1ST_LEVEL ORDER BY bucket;
psql:include/cagg_on_cagg_common.sql:212: ERROR:  relation "conditions_summary_1_hourly" does not exist at character 15
\set ON_ERROR_STOP 1
